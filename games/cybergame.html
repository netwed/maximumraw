<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cybersecurity Word Search</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .title {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 20px;
        }

        .grid-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            max-width: 100%;
            overflow-x: auto;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(20, minmax(25px, 30px));
            gap: 1px;
            background: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
        }

        .cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s;
        }

        .cell.selected {
            background: #e3f2fd;
            color: #1976d2;
        }

        .cell.found {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .cell.completed {
            animation: flash 1s infinite;
        }

        @keyframes flash {
            0% { background: #e8f5e9; }
            50% { background: #81c784; }
            100% { background: #e8f5e9; }
        }

        .word-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            max-width: 800px;
            justify-content: center;
            margin: 20px 0;
        }

        .word {
            padding: 5px 10px;
            background: white;
            border-radius: 15px;
            font-size: 14px;
            transition: all 0.3s;
        }

        .word.found {
            background: #e8f5e9;
            color: #2e7d32;
            text-decoration: line-through;
        }

        .reset-button {
            padding: 10px 20px;
            font-size: 16px;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .reset-button:hover {
            background: #1976d2;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: repeat(20, minmax(20px, 25px));
            }
            
            .cell {
                font-size: 14px;
            }

            .word {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <h1 class="title">Cybersecurity Word Search</h1>
    <button class="reset-button" id="resetButton">New Game</button>
    <div class="grid-container">
        <div class="grid" id="grid"></div>
    </div>
    <div class="word-list" id="wordList"></div>

    <script>
        const gridSize = 20;
        const wordsPerGame = 34;
        const allWords = [
            "ENCRYPTION", "FIREWALL", "HACKER", "PASSWORD", "MALWARE",
            "PHISHING", "BACKDOOR", "VIRUS", "SECURITY", "TROJAN",
            "SPYWARE", "KEYLOGGER", "PATCH", "AUTHENTICATION", "RANSOMWARE",
            "NETWORK", "BREACH", "PROTOCOL", "INTRUSION", "ZERO",
            "HASHING", "CERTIFICATE", "SOFTWARE", "MULTIFACTOR", "EXPLOIT",
            "PRIVACY", "BOTNET", "ATTACK", "DEFENSE", "RISK",
            "VULNERABILITY", "FORENSICS", "ACCESS", "CONTROL", "PROTECTION"
        ];

        class WordSearch {
            constructor() {
                this.grid = Array(gridSize).fill().map(() => Array(gridSize).fill(''));
                this.words = [];
                this.selectedCells = [];
                this.foundWords = new Set();
                this.isSelecting = false;
                this.startCell = null;
                this.directions = [
                    [0, 1],   // right
                    [1, 0],   // down
                    [1, 1],   // diagonal down-right
                    [-1, 1],  // diagonal up-right
                    [0, -1],  // left
                    [-1, 0],  // up
                    [-1, -1], // diagonal up-left
                    [1, -1]   // diagonal down-left
                ];
            }

            initializeGame() {
                this.words = this.selectRandomWords();
                this.createGrid();
                this.renderGrid();
                this.renderWordList();
                this.setupEventListeners();
            }

            selectRandomWords() {
                return [...allWords]
                    .sort(() => Math.random() - 0.5)
                    .slice(0, wordsPerGame);
            }

            canPlaceWord(word, row, col, dRow, dCol) {
                const len = word.length;
                
                // Check if word fits within grid bounds
                if (row + dRow * (len - 1) < 0 || row + dRow * (len - 1) >= gridSize ||
                    col + dCol * (len - 1) < 0 || col + dCol * (len - 1) >= gridSize) {
                    return false;
                }

                // Check if path is clear or has matching letters
                for (let i = 0; i < len; i++) {
                    const newRow = row + dRow * i;
                    const newCol = col + dCol * i;
                    if (this.grid[newRow][newCol] !== '' && 
                        this.grid[newRow][newCol] !== word[i]) {
                        return false;
                    }
                }
                return true;
            }

            placeWord(word) {
                const shuffledDirections = [...this.directions]
                    .sort(() => Math.random() - 0.5);

                for (let attempts = 0; attempts < 100; attempts++) {
                    const row = Math.floor(Math.random() * gridSize);
                    const col = Math.floor(Math.random() * gridSize);
                    
                    for (const [dRow, dCol] of shuffledDirections) {
                        if (this.canPlaceWord(word, row, col, dRow, dCol)) {
                            // Place the word
                            for (let i = 0; i < word.length; i++) {
                                this.grid[row + dRow * i][col + dCol * i] = word[i];
                            }
                            return true;
                        }
                    }
                }
                return false;
            }

            createGrid() {
                this.grid = Array(gridSize).fill().map(() => Array(gridSize).fill(''));
                const sortedWords = [...this.words].sort((a, b) => b.length - a.length);
                
                // Attempt to place all words
                for (const word of sortedWords) {
                    if (!this.placeWord(word)) {
                        // If word placement fails, start over
                        return this.createGrid();
                    }
                }

                // Fill empty cells with random letters
                const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        if (this.grid[i][j] === '') {
                            this.grid[i][j] = letters[Math.floor(Math.random() * letters.length)];
                        }
                    }
                }
            }

            renderGrid() {
                const gridElement = document.getElementById('grid');
                gridElement.innerHTML = '';
                
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.textContent = this.grid[i][j];
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        gridElement.appendChild(cell);
                    }
                }
            }

            renderWordList() {
                const wordList = document.getElementById('wordList');
                wordList.innerHTML = '';
                
                this.words.sort().forEach(word => {
                    const wordElement = document.createElement('div');
                    wordElement.className = 'word';
                    wordElement.textContent = word;
                    if (this.foundWords.has(word)) {
                        wordElement.classList.add('found');
                    }
                    wordList.appendChild(wordElement);
                });
            }

            handleSelection(cell) {
                if (!this.isSelecting) return;
                
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                if (this.selectedCells.length === 0) {
                    this.selectedCells.push(cell);
                    cell.classList.add('selected');
                    return;
                }

                const firstCell = this.selectedCells[0];
                const firstRow = parseInt(firstCell.dataset.row);
                const firstCol = parseInt(firstCell.dataset.col);
                
                // Calculate direction
                const dRow = Math.sign(row - firstRow) || 0;
                const dCol = Math.sign(col - firstCol) || 0;
                
                // Check if selection follows a straight line
                if (this.selectedCells.length === 1) {
                    this.direction = [dRow, dCol];
                } else {
                    const expectedRow = firstRow + this.direction[0] * this.selectedCells.length;
                    const expectedCol = firstCol + this.direction[1] * this.selectedCells.length;
                    if (row !== expectedRow || col !== expectedCol) return;
                }

                if (!this.selectedCells.includes(cell)) {
                    this.selectedCells.push(cell);
                    cell.classList.add('selected');
                }
            }

            checkWord() {
                const word = this.selectedCells.map(cell => cell.textContent).join('');
                const reversed = word.split('').reverse().join('');
                
                if ((this.words.includes(word) && !this.foundWords.has(word)) ||
                    (this.words.includes(reversed) && !this.foundWords.has(reversed))) {
                    const foundWord = this.words.includes(word) ? word : reversed;
                    this.foundWords.add(foundWord);
                    this.selectedCells.forEach(cell => {
                        cell.classList.remove('selected');
                        cell.classList.add('found');
                    });
                    this.renderWordList();
                    this.checkCompletion();
                    return true;
                }
                return false;
            }

            checkCompletion() {
                if (this.foundWords.size === this.words.length) {
                    document.querySelectorAll('.cell').forEach(cell => {
                        cell.classList.add('completed');
                    });
                }
            }

            setupEventListeners() {
                const gridElement = document.getElementById('grid');
                
                const handleStart = (e) => {
                    e.preventDefault();
                    const cell = e.target.closest('.cell');
                    if (!cell) return;
                    
                    this.isSelecting = true;
                    this.selectedCells.forEach(cell => cell.classList.remove('selected'));
                    this.selectedCells = [];
                    this.direction = null;
                    this.handleSelection(cell);
                };

                const handleMove = (e) => {
                    e.preventDefault();
                    if (!this.isSelecting) return;
                    
                    const cell = e.type === 'touchmove'
                        ? document.elementFromPoint(
                            e.touches[0].clientX,
                            e.touches[0].clientY
                          ).closest('.cell')
                        : e.target.closest('.cell');
                    
                    if (cell) this.handleSelection(cell);
                };

                const handleEnd = () => {
                    if (!this.isSelecting) return;
                    this.isSelecting = false;
                    
                    if (!this.checkWord()) {
                        this.selectedCells.forEach(cell => cell.classList.remove('selected'));
                    }
                    this.selectedCells = [];
                    this.direction = null;
                };

                gridElement.addEventListener('mousedown', handleStart);
                gridElement.addEventListener('mousemove', handleMove);
                document.addEventListener('mouseup', handleEnd);

                gridElement.addEventListener('touchstart', handleStart, { passive: false });
                gridElement.addEventListener('touchmove', handleMove, { passive: false });
                document.addEventListener('touchend', handleEnd);
            }
        }

        // Initialize game
        let game = new WordSearch();
        game.initializeGame();

        // Reset button
        document.getElementById('resetButton').addEventListener('click', () => {
            game = new WordSearch();
            game.initializeGame();
        });
    </script>
</body>
</html>